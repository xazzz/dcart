System Design
==============

I want to write a better app framework, and from this framework, we can extend it easily.

The idea is inspired from Unix-alike operationg system especially OSX.
To treat different module as <Process>,
and for each of them it will consist of <Command> and <Service>,
that's <Process> is an app in the file system in its own storage container.

It could be a distributed unit for future development,
and by exchanging data from each other efficiently,
the same level app will be running parallel in different <Node>

    Install & Uninstall : will be installed and uninstalled cleanly from storage system

        copy and paste to one place

            system : system for the core of the system, in system space
            user : the code is from user, in user space
            vendor : the third part code, in vendor space

        the installer of <Process> will be called when its installed
        the uninstaller of <Process> will be called when its uninstalled
        the app list will be built and updated everytime one is installed...
        the app list will be build and updated

        to maintain the app list in the system, and install one of them or uninstall one of them

            database == application ==
                Id
                UUID : com.domain.user <simlar to the provision in iOS>
                GUID : ?? global name of the app
                name
                author
                developer ID
                version
                md5 (of app zip bundle)
                date

            the core database will be in sqlite...

    Update it : will be updated if the new <Process> is updated from some source

        get info from the app store, and check its version & md5 (of zip file)
        download it to temperory installation folder

        code is identified by GUID : com.domain.xxxx ==> that's the global name
        code is signed with certificate :

        remove code part of the app ==> *.phar? or *.php?
        retain the system supply folder ==> /Document /Temp /Library
        retain the data in /Document or clean it <decided by new Process> ==>
        remove it from tempeory installation folder

    Bundle is a container : all resource will be in one container

        will add all resources in app folder
        will be static files only
        will have container ID


    Extend it :

        replace Command : re-write and update it
        replace Service : re-write and update it

        Command :

            hide/remove Class
            replace Class

            hide/remove method
            replace method
            inject into method
            add method to it

            chain to injected object

        Service :

            hide/remove Class
            replace Class

            hide/remove method
            replace method
            inject into method
            add method to it

            chain to injected object


    Communication :






=========obsolete=================


    If there any error, it will be able to log into the system <to know, which Process, which Command / Service, which Class / method, and which Line>...<location_command_ID_version (optional)> ==> <system_command_order_version> / <system_service_order_version>


$this->invoke ($object, $method, $parameter);
$object->$method ($parameter, $this);

object {
    function method ($parameter, $this)
    {
        if (...exists ($this, "....")) {

            $this->.....;

        } else {


        }


    }
}


This framework should be like that, commonly a web application is consist of MVC modules, and from controller we will handle different request, also all of them are open source most of time, that seems very nice. Even so, we will have to bring more flexible structure into it, so we can extend it, and change it without any modification of the core system, is that possible?

We will add new MVC, that's one.
We will be able to add new controller, and use old Model & View.

That sounds enough, but not. When a web app is built for an e-commerce software, for example, web store, it will have its own workflow, even for blog, we will have same issue. Sometimes, we need to change the data in the workflow, or running some extra code in the workflow, that means, we will have to inject code into the core system.

We will be able to change data in the workflow
We will be able to run extra code in the workflow

That's not easy to do without changes of core system code, so the solution is the core system have to open its workflow and all kinds of API for other modules, and then for any new module, they can use this API to change the data or run extra code. That's the only way, people think they can use OOP inherit feature to do that without changes of core system code, that's not possible. From a derived class, you can call any method from the parent class, but you can't do intercept of any of its method.

So for any part of the system, we equally create different module, and for each of them, we will have MVC design pattern.
We have two type of functionality from OS perspective, Command <app for user> or Service <app for command & service>, they are both belong to Process.

For any of these Command or Service, we will have to write open API for other part of the system and they are pre-defined format.
Those API will be one purpose, HOOK into the workflow of the module..
The HOOK == before | after | replace

The API could be in Controller, Model or View.
If it's in Controller, it will be easy to handle...
If it's in View, well...

If it's in Model, and it want to handle the data from the save Model, we will need a stack condition query...
If it's in Model, should leave only the query in it, and all condition out of it...
If the method in Model is not enough, then write a new one from your own...
If the method in Model is not enough, then replace the one from your own, but the replaced API should be updated too...

stack_conditions :

    condition1 :
        "OR" | "AND" =>
            key1 => value1
            key2 => value2
            ...

    condition2 :
        "OR" | "AND" =>
            key1 => value1
            key2 => value2
            ...

SELECT * FROM table1 INNER JOIN table2 ON table1.xxxx = table2.xxxx INNER JOIN ...... WHERE ......

query->push (condition1);
query->push (condition2);
query->run ();

For example, there is a product page :

    product in category
    product in search by keyword
    product by filter

    product by category & filter
    product by A & B & C & D

The query inside model should be the complete one, not combined one...
if we have the query product in category & filter, but we want to do get product by filter...

If the HOOK API is in view, view data all from controller, and the data changed the view should change too...
So any new data we added, that will bring different changes...
So we will use widget to display the data...

ALl new widget will be placed into one of the area, and we define zone for the view...
To hook into the zone is not a easy way, so who define the zone...

How to do........

Header
Body ==>

    Line A
    Line B
    Line C

Footer

The zone is defined and template, any template of View should open its ZONE for developer...



User ==> Command ==> Extension / Service ==> Process ==> Object <Computer A>
User ==> Command ==> Extension / Service ==> Process ==> Object <Computer B>

Flexible module ==> Command & Service ==> Command <UI> <==> Service <API>

// Could lazy load Service

Service A, Service B, Service C ......
Command <==> Shared .....

// how to use Command

$app ==> register Command ==> register routers ==> (MVC) ==>
Command ==> register to Core queue ==> (MVC) ==> call service API ==> ......

// how to use Model

search ==> query + condition ==> condition stack ==> result


System ==>

    Web framework

        Silex
        Symfony
        ....

    Core

        Installer
        Driver
        Queue

    Process

        status
        priority
        user_uuid
        user_group_uuid

        stack ==> database
        queue ==> database, process A <==> process B

        start
        stop
        sleep
        wake

        entry ==> main
        loop ==> process message queue

    Extension <== Process

        hook
        chain

        the meaning of extension, is about to provide different module <library> for different purpose, it's not like the web framework sometimes, it's part of the app. More than an library, extension sometimes will have to inject into another extension, for example, if we have an order extension, and you want to add an email notification in it, you can just inject into the order extension, and after the order is created, you can send the email notification with your own templates. That's flexible coz you don't have to create all the system for the e-commercial software, you only have to provide the bone of it - cart, order, payment.

        So from this point, we created extension from Process, but we will need to define its HOOK API, and for each of them, there will be a queue for it to run them one by one. The extension is designed by different programmers, so it have to open its HOOK API to others, and tell them what part of it is open and how to use them. For example, the email notification extension could have a hook point, that another template extension could replace its template system, so user could select different template to extend it.


    Command <== Process

        install
        uninstall

        the meaning of command, is about to provide the interface for user request, and for each of them, it will provide the routers (interface). When it is installed, it can handle user request. Command can use any API from extension, it's rely on extension API & framework API.


Just want to write an simple & opened e-commerce software.

I have been working on e-commerce software almost for 6 month, I saw a lot flaws from their system.

1. their system is really limited one, when you are working on an e-commerce software framework, you are not only working on an e-shop but an e-business portal, you probably don't know what I am talking about, let me give you an example. If the business isn't about selling & ordering on the website, but rather just an cart? In this case, people only use the cart in the system...

2. better API system, and no need to change core code anymore, especially when you want to add some more functionality of it. I am working on an upload & order system, from this system, user will upload their product and order to print the product, and then they can buy it, there are a lot changes in the system, including change the order system and so on, so how to make it better?


OPEN API
=========

The api system is core system of the e-commerce software I think, yes some of them provide extension, or else, but it's not good enough, if you want to use the core system functionality, they still have to change it! Even worse, the open-cart system, they use vqMOD to replace the code!! Thus one extension could break another one...

The OPEN API, is not all about self-contained MVC code, also the hook APi in the system, wordpress is an good example, even it's not intended to do so, but it's doing it this way.

HOOK API == WORKFLOW
=====================

To make hook API, we will need more better way to understand the workflow of the system, and from each of them, the extension can hook their API in it, the API should be chained together, so any input parameter is same, and they have to output the same exact format too. Let's see order part.


    In shopping cart

        - before
        - in_the_middle_of
        - after

    Order : Confirm

        - before
        - in_the_middle_of
        - after

    Order :



HOOK API == LOAD & UNLOAD
==========================

To make hook API flexible, we should move all tightly related code (could be disabled possibly) to outside of the core system. For example, if you want to replaced the whole order confirm system, you should be able to do it, coz the order confirm system is an extension.

    - core/
        - model
        - admin
            - controller
            - helper
            - view

    - extension/
        - system
            - payment
            - order
            - cart
            ......
        - user
            - folder A // created by admin
            - folder B
            ......

        - vendor
            - folder A // created by admin
            - folder B
            ......

    - template/
        - system
            - themeA
            - themeB
            - themeC

        - user
            - themeA
            - themeB
            - themeC

        - vendor
            - themeA
            - themeB
            ....

    - public
        - system
        - user
        - vendor
        - assert
            - css
            - script
        - cache
        - upload
            -

        index.php
        config.php

    system_unload_extension
    system_load_extension

HOOK API == HOW TO HOOK
==========================

To make hook API flexible, we should move all tightly related code (could be disabled possibly) to outside of the core system. For example, if you want to replaced the whole order confirm system, you should be able to do it, coz the order confirm system is an extension.

    Register to the system

        extension_domain : my_extension
        entry_point : class::function::($app);

        put them into ==> queue ==> sqlite db / mysql

    Load extension

        foreach ($queue_extension as $name => $extension) {

        }

    Hook

        @question : if there are two actions conflict exist, user should unload one of them
        @question : for example, two email template system // will send two email if they both installed

        // every extension should open its HOOK too...
        // every extension has its HOOK queue
        // every extension should open it to other developer

        foreach ($queue_extension as $name => $extension) {

            - A ==> action ==> A.queue_extension ==>
            - B ==> action ==> B.queue_extension ==>
            - C ==> action ==> C.queue_extension ==>

        }

        if (system_extension_exist ($domain, $version) {

            if (false != ($queue = system_get_queue_from_extension ($domain, $version))) {

                $queue->add ();

            }
        }

    Unload & Load dynamically

        system_load_extension
        system_unload_extension

        foreach ($queue_extension as $name => $extension) {

            - A ==> action ==> system_unload_extension
            - B ==> action
            - C ==> action

        }

     Asynchronous task

        //http://www.davenewson.com/dev/methods-for-asynchronous-processes-in-php

        if one extension want to be an asynchronous task, then we will do this

        ob_end_clean();
        header("Connection: close");
        ignore_user_abort(true);

        echo ('Text the user will see');

        $size = ob_get_length();
        header("Content-Length: $size");
        ob_end_flush();                   // Strange behavior; this will not work unless..
        flush();                          // both functions are called !

        // Do processing here

        bottom-half.php

            sleep(30);
            //echo('Text user will never see');
            //run task

            foreach ($queue_async_task as $name => $task) {

                // run task here

            }

    Transaction

        if one extension require transaction, we will use an database table for that
        unless the transaction is complete, otherwise it will be roll-back

        // how to?

    Resource

        // we have to use lock to this critic resource...
        // Semaphore, Shared Memory and IPC



HOOK API == DATA EXTENSION
===========================

To make hook API complete, we should enable adding extra data type into the db system. Even we can make a simply almost complete database system for e-commerce business, but we can't make sure it can suit for every requirement. So when user want to add extra data column to the current database table? We will make that happen too.

    order
        order_id
        ......

    order meta

        order_meta_id
        order_id
        domain : extension domain
        type : string, integer....
        name : display name
        value :
        ....

    SELECT o.* FROM order AS o INNER JOIN order_meta AS om ON o.order_id=order_meta.order_id WHERE domain='my_domain';
    or better two SQL ==> one for each ==>

Thinking
===========

Sometimes you will have to think about an web application as an operating system, and this time you will think about how to schedule the task and also how to run signal, as well you will deal with resource lock sometimes.

If we think about the web application as an operating system, you will have the core scheduler, and it will run task based on its ticket, normally that's not a problem, coz all task will be running inside the operating system.

For some part of the system, we will take them as process or task, we will deal with them in different queue, and in each of them, they will be scheduled and run sometime, basically it's a FIFO, sometimes you can add more factors.

The resource could be required and the competition happened sometimes, so you will have to use IPC or something similar.

Web app
========

    Task ==> from each user call ==> open URL
    Task ==> service ==> internal system
    Signal ==> called in task scheduler bottom half ==>

    System call ==>
    Interrupt ==>
    Exception ==>

System
==========

About the system file structure, I think the problem is all we want to be a flexible and loose connected system, but theme seems always connect one to another. We can make different extension, and for some of them, we will provide their controller & view system, also routers, so from these facilities, you can put them into any part of the web page framework.

This time, how do you deal with that one web page framework could include many extension views, and for each of them, how to connect them together, but still keep it's clean and simple.

Lets start it from admin portal, the core system is all about service & helper and so on. There is no any specific theme in it, so no web page framework. Still we will have to define an web page framework for it, and this one will include many extensions. And for each extension, we will actually designed it to be an part of the functionality of the web page framework, and it have to provide web UI of it.

Admin extension
===============

Queue
    type
    queue

Navigation
    type


Navigation ==> Container ==> Menu system
Menu system ==> Menu Item container ==> Menu items ==> Menu item ==> Sub menu item container ==> Extension

Menu Item container ==>
    Item
    Item
    Item

Item ==> one or more web pages in one system
Item ==> extension A :: route A
Item ==> extension B :: route B

foreach (menu_system_array as $name => $menu) {

    if (is_array ($menu)) {

        // $name ==>
    }

}

Level = 0, 1, ....
name = _t()......
link = ......
container = ...... = system | user | vendor + extension name
id = system | user | vendor + extension name
sort_order = 0, 1, ....
type = divider | container | single item


   - core/
        - model
        - helper

    - extension/
        - system
            - admin
                - basic module for administration theme framework
                - from this module we will create administration theme
                - and we will have - extension - role - user - customer - merchant

            - user
                - route
                - controller
                - view

                - authenticate user
                - authorize user
                - roles
                - permission

            - customer

            - merchant
            - payment
            - order
            - cart

        - user
            - folder A // created by admin
            - folder B
            ......

        - vendor
            - folder A // created by admin
            - folder B
            ......

    - template/
        - system
            - themeA
            - themeB
            - themeC

        - user
            - themeA
            - themeB
            - themeC

        - vendor
            - themeA
            - themeB
            ....

    - public
        - system
        - user
        - vendor
        - assert
            - css
            - script
        - cache
        - upload
            -

        index.php
        config.php

